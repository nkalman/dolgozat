\chapter{Az alkalmazás felépítése}\label{ch:ALKALM}

Annak érdekében, hogy algoritmusunk könnyen felhasználható és alkalmazható legyen a mindennapi életben, szükségessé vált egy barátságos felhasználói felületet készítenünk hozzá. Erre a legalklamasabbnak egy telefonos alkalmazás tûnt. Így a felhasználó a kép készítése után rögtön elemezheti is a képet, s ha az nem bizonyul elég sikeresnek, az alkalmazás segítségével optimizálhatja, s így már egy kész remekmûvel dicsekedhet. 


Mivel az algoritmusunk meglehetõsen erõforrásigényes, nem bízhattuk ezt a munkát a felhasználók okostelefonjára. Ennek érdekében esett a választás a ReST alapú kommunikáció alkalmazására. Ezért egy szerver alkalmazás végzi a képelemzõ, képértékelõ feladatokat, míg a kliens csak kéréseket küld a szerver felé, illetve feldolgozza, és megjeleníti a kapott választ.  

\section{Szerkezete}\label{sec:ALKALM:szerk}

\begin{figure}[H]
\centering
   \label{fig:topologia}
\pgfimage[height=6cm]{kepek/topologia}
\caption[meanshift]
  {Az alkalmazás szerkezete}
\end{figure}


\section{Felhasznált technológiák}\label{sec:ALKALM:ft}

A kliens alkalmazást Android okostelefonokra terveztük, ugyanis széleskörûen elterjedt, egyben ez rendelkezik a legnagyobb felhasználói bázissal. Fontos szempont volt tehát az, hogy minél több felhasználó számára elérhetõ legyen ez az alkalmazás. Mivel a képelemzõ és feldolgozó algoritmusok igencsak erõforrásigényesek, nem bízhattuk ezen feladatokat az okostelefonokra. Éppen ezért szükségessé vált ezen számításokat egy szerverre bízni. Ezt a szerveralkalmazást valamilyen módon el kellett érnünk a kliens oldalról is. Választásunk a ReST alapú kommunikációra esett, ennek érdekében a kliens  HTTP kéréseket küld a szervernek, melyekre szinten HTTP válaszokat vár. A kommunikációra kliens oldalon a Retrofit-ot használtuk, mely egy kliens Android és Java számára. Ez nagyban megkönnyíti a JSON formátumú üzenetek köldését és fogadását ReST alapú web service-eken keresztül. A Retrofit-on belül OkHttp könyvtár van használva a HTTP kérések küldésére.

Mivel az algoritmusunk Java programozási nyelvben íródott a szerver alkalmazás megírására is ezt a nyelvet válsztottuk. A web service-ek megalkotására a JAX-RS specifikáción belül a Jersey implementációt alkalmaztuk. A JAX-RS annotációkat használ a Java osztályok ReST függõségeinek megadásához. A Jersey implementáció pedig egy könyvtárat biztosít a Restful web service-ek implementálására egy Java servlet konténerben. Alkalmazásunk esetében az Apache Tomcat servlet konténerre esett a választás. 

\section{Az Android kliens bemutatása}\label{sec:ALKALM:android}

A kliens alkalmazásunk három activity-bõl áll: MainActivity, SelectedImageActivity és GalleryActivity. E három oldal funkcionalitásaiból épül fel a képelemzõ applikációnk. 

Az alkalmazás beindításakor a MainActivity jelenik meg legelõször. Itt a felhasználó eldöntheti, mit is szeretne kezdeni az applikációval. Három lehetõséget kínál az activity: új fénykép készítését, meglevõ fénykép kiválasztását a galériából, illetve a már analizált és esetlegesen optimalizált képek galéria-szerû megjelenítését. Ezek az opciók egymás alatt találhatóak és LinearLayout alkalmazásával lettek elhelyezve. Egy ilyen választási lehetõség megjelnítés szempontjából 2 részbõl áll: baloldalt egy, az esemény számára reprezentatív kép, jobboldalt pedig egy leírás. Ez a két komponens szintén LinearLayout-al lett elhelyezve. Ezeket a képeket igyekeztünk úgy megválasztani, hogy a felhasználó számára a leírás elolvasása nélkül s egyértelmûvé váljon, mi is fog történni, ha az adott opciót választja. Ha az elsõre, azaz a fénykép készítésére esett a választás, akkor betöltõdik az alapértelmezett kamera applikáció, ahol a kép készítése után ezt el tudjuk fogani, vagy újabb képet tudunk készteni. Ha elfogadtuk a képet, az applikáció a SelectedImageActivity-hez navigál. Ha a második, azaz a kép válogatása lett kiválasztva, akkor a Gallery applikáció töltõdik be, itt a telefonon levõ összes kép közül tudunk válogatni, ha pedig kiválasztottunk egyet, akkor szintén a SelectedImageActivity-hez leszünk irányítva. Ezzel ellentétben, ha az utolsó opcióra esett a választás, akkor a GalleryActivity töltõdik be. Mivel az activity-k közötti váltás intent-ek segítségével történik, és nekünk szükségünk van a kiválasztott vagy készített képre a SelectedImageActivity-ben is, ezért ezen képek Uri-ját extra információként meg kell adjuk a navigáló intent-ekbe. Ehhez azonban a frissen készített képet el is kell mentenünk. Az applikáció könyvtárán belül létrehoztunk ezért egy Pictures könyvtárat, melybe úgy a frissen készített, mint a kiválasztott képet elmentjük, annak érdekében, hogy majd galária-szerûen meg tudjuk jeleníteni a késõbbiekben. A képek mentése esetén egy $JPEG\_timestamp$ formátumú elnevezést alkalmaztunk, így biztosan nem lesz két kép ugyanazzal a névvel ellátva.

A SelectedImageActivity feladata, hogy megjelenítse a kiválasztott vagy éppen frissen készített képet egy ImageView-ban. E mellet fontos szerepet játszik az activity-ben a jobb alsó sarokban található $ANALYZE$ feliratú gomb, melyre kattintva a kép el lesz küldve a szerver számára, ahol megkezdõdhet ennek az értékelése. E két elem, azaz az ImageView és a gomb egy CoordinatorLayout-ban van elhelyezve. Az activity ActionBar-ja nincs ellátva névvel, helyette rendelkezik egy vissza gombbal, ami valójában egy balra mutató nyíl, és erre kattintva a MainActivity-hez irányít vissza minket az applikáció. Az ActionBar jobb oldalán pedig található egy $ANALYZE$ gomb, egy megosztó gomb, illetve egy beállítások gomb. Az $ANALYZE$ feliratú gomb ugyanazzal a funkcionalitással van ellátva, mint a jobb alsó sarokban található gomb. Néhány felhasználó ezt a funkcionalitást is az ActionBar-ban keresné, éppen ezért került ide is be. A megosztásra kattintva egy $ACTION\_SEND$ típusú intent jön létre, melybe extra információként bekerül az aktuális kép uri-ja, így a képet könnyedén meg lehet osztani más applikációkkal, többek között üzenetként elküldeni más felhasználónak, megosztani a Facebook-on, vagy éppen elmenteni a to-do listánkba. Végül, az ActionBar utolsó eleme a beállításokért felelõs. Erre, a fogaskerékkel jelzett opcióra kattintva beállíthatjuk a szerver IP címét. Ekkor megjelenik egy AlertDialog, ami egy címmel, rövid leírással és egy EditText-el rendelkezik. Az EditText alapértelmezetten az aktuálisan beállított IP címmel van kitöltve. Ezt egyszerûen módosíthatjuk, fontos azonban, hogy valódi IP cím formátumot adjunk meg. Ha mégis hibás a megadott formátum, akkor megjelenik egy másik AlertDialog, ami közli a felhasználóval, hogy helytelen a megadott IP cím. Itt az OK-ra kattintva, visszakerülünk az IP beállításokat tartalmazó AlertDialogba, ahol ismét megadhatjuk a kívánt címet. 

A kép analizálására kattintva elõbb ellenõrizzük az internetkapcsolatot, hiszen hogyha nincs internetkapcsolat, akkor teljesen feleslegesen próbálnánk meg HTTP kérést küldeni. Mivel a Post kérésben kell a szerver az egész képelemzõ mûveletet elvégezze, mely idõigényes, a válaszra igen hosszú ideig kellene várjon a kliens. Ez nagy valószínûséggel túllépné a kliens kérése által alapértelmezetten beállított várakozási idõt, s ennek megfelelõen TimeoutException keletkezne, s a kérés nem kapná meg a választ. Ennek elkerülése érdekében a timeout-ot átállítottuk másfél percre. Tapasztalataink alapján ez idõ alatt a kérésre biztosan érkezik válasz is. Azonban így minden kérés esetén másfél percet kellene várnunk, s csak azután vennénk észre, hogy valami gond történt. Ez felesleges várakozási idõ lenne abban az esetben, ha például a szerver éppen leállt, vagy a felhasználó nem a szerver IP címét adta meg, s így nem tudja elérni a szerverünket a kérés. Emiatt vált szükségessé egy másik kérés létrehozása, mely nem rendelkezik meghosszabbított timeout-al. Ez egy HTTP Get, melyben egyszerûen csak egy kérést küldünk a a szervernek, s ha ettõl megkapjuk  a választ, akkor tudjuk, hogy az IP cím is helyes, és a szerver is fut, azaz küldhetjük a képelemzõ kérést a szervernek. Miközben a kliens a válaszra várakozik, az applikációban megjelenik egy ProgressDialog, mely jelzi, hogy mi történik éppen, mire kell várni. A képoptimalizálás válasza egy JSON formátumú üzenet, mely a kivágott, maximális esztétikai értékkel rendelkezõ képrészlet koordinátáit, eredeti és optimalizált értékét tartalmazza. Ezen koordinátákat megkapva a kliens egy AlertDialog-ban megjeleníti a kép eredeti értékét, az optimalizált értékét, illetve a koordinátákat is. Az AlertDialog megkérdi a felhasználót, hogy szeretné-e alkalmazni a kivágást a képre. Ha pozitív válasz érkezik a felhasználótól, akkor az alkalmazás megjeleníti a kivágott képrészletet, s egyben el is menti az applikáció könyvtárába, $JPEG\_timestamp\_optimized$ formátumú névvel.

Fontos megemlítenünk, hogy az IP cím elmentéséhez a singleton tervezési mintát alkalmaztuk. Erre azért volt szükség, mivel az applikáció futása során meg kell jegyezze mindig az aktuálisan beállított címet. Kellemetlen volna, ha az activity-k közötti navigálás során mindig újra és újra be kellene állítani az IP-t. A singleton programtervezési minta egy objektumra korlátozza egy objektum példányainak számát, illetve fontos tulajdonsága, hogy ez a példány lehetõleg mindenhonnan elérhetõ legyen. Ennek megfelelõen a létrehozott IPAddress példányunk is elérhetõ és állandó: addig ugyanazt az értéket tartalmazza, amíg azt a program egy adott pontján meg nem változtatjuk. 

Amint már említettük, a kliens a Retrofit implementációt használja a HTTP kérések küldlésére és fogadására. Ehhez azonban elõbb létre kell hozni egy interfészt, melyben definiáljuk a végpontokat. Ez az interfész Retrofit annotációkat használ a kérésekhez és  paramétereikhez tartozó információk megadásához. A visszatérési érték mindig Call<ResponseBody> típus. Applikációnk keretén belül ez az interfész a Service osztály által van megadva, mely értelemszerûen egy @GET és  @POST annotációval ellátott függvényt tartalmaz.


\section{A szerver bemutatása}\label{sec:ALKALM:webservice}

A kliensnél bemutatott funkcionalitásokból adódóan a webszerverünk csak két ReST útvonallal rendelkezik: egy Post kéréshez tartozó útvonallal, melyre az elemezni kívánt képet küldjük, illetve egy Get kérésnek megfelelõ útvonallal, mely a szerver ébrenlétét hivatott leellenõrizni. A Post kéréshez tartozó útvonal: http://localhost:8084/PhotoAnalyzer/rest/file/upload a ReST elvárásoknak megfelelõen önmagában is beszédes, látható, hogy a PhotoAnalyzer szerverhez irányítjuk kérésünket, mely rest hívást vár el, és konkrétan egy file feltöltést végzünk. A http://localhost:8084/PhotoAnalyzer/rest/alive pedig a Get kérés útvonala, melybõl szintén látható a funkcionalitás, azaz a szerver ébrenlétének ellenõrzése.

A szerver ébrenlétének ellenõrzésekor egy  paraméter nélküli Get kérés történik, mely egy egyszerû szöveges üzenetet ad válaszként. Ha a kliens megkapja ezt a választ, az azt jelenti, a szerver mûködik, tehát elküldheti a valódi kérést: a képet tartalmazó Post-ot. Ha valamilyen okból ezt a választ nem kapja meg  a kliens, akkor egyértelmûen valami gond történt menet közben: vagy megszakadt az internetkapcsolat, vagy rossz IP-cím lett beállítva a kliens által, vagy éppen leállt a szerver. Ilyen esetben a kliens értesíti a felhasználót a problémáról. Ennek a kérésnek a lekezelésére egy az IsAliceService nevû web service-t hoztunk létre szerver oldalon.

Az elõbb említett Web Service mellett csak egyetlen létezik, az UploadFileService, mely a kép feltöltéséért, elemzéséért és a válasz visszaküldéséért felelõs. Ez a service képezi a találkozási pontot a webszerver és maga az általunk kidolgozott algoritmus között. Miután a szerver sikeresen megkapta a feltöltött képet, ideiglenesen lementi egy erre létrekozott folderbe, a könnyebb hozzáférés végett. Ezután az Analyzer osztályt felhasználva megtörténik a képen található fõ objektumok és vonalak detektálása, illetve az optimális képrészlet megkeresése a genetikus algoritmus segítségével. Észrevehetõ, hogy a teljes algoritmusnak ennek a Post kérésnek a keretén belül kell lefutnia. Ez azonban idõigényes folyamat, pontosan ezért vált szükségessé megfelelõ hosszúságú timeout beállítása a kliens oldalán. Mégis, hogy energiát és idõt spórolhassunk, válaszként nem a kész, kivágott képet küldjük vissza, hanem csak ennek a paramétereit: a bal felsõ sarkának x és y koordinátáját, illetve a szélességét és hosszúságát. Végül, hogy a szerver se tartalmazzon fölösleges információkat, az elõzõleg feltöltött, elmentett képeket töröljük.


